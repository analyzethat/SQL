Fundamentals of RDBMS and Database Designs

Introduction

Hi, this is Pinal Dave for Pluralsight. In this module, we will cover Fundamentals of RDBMS and Database Designs. In the last module, we learned how to install MySQL and GUI Tool, MySQL Workbench. Before we start with MySQL Database architecture design and object creation, it is a good idea to understand Fundamentals of RDBMS and Database Design. In this module, we will understand what is Client/Server System architecture, how Web Application Server and Database work together. Additionally, quickly we will see History of Relational Database Model and right after that we will understand Key Concept of RDBMS. We will understand what is table, column, rows, cells, and a few other key concepts.

Client/Server System

We will be using SQL to access MySQL Database. At that time, the system is often called Client/Server System. Let's understand Client/Server System. There are three important components for any Client/Server System. Clients: Clients are like PCs, Macs, laptops, tablets, smartphones, etc. Server: Server usually stores files. When Server stores database along with files, it is called Database Server. MySQL is Database Server application. Networks: Networks are communication links between Client and Server. Beside including lines and cables, Network also includes hubs, router, and other interface components. In many enterprises, large database files are also stored on a network storage. Networking components connect server with network storage. In simple topology, client and server are both on a same network. They are often known as land or local area network. If there are more than two lands located in a separate geographic location, that's called WAN, which is wide area network. If we assume there is a database on this Client/Server System, we can say that client sends a request in terms of the SQL query to the server. Server, in turn, passes the same SQL query to the database and database query returns the results back to the client and then the client, which can be PC, Mac, audio handheld devices, will display the result.

Web Application Server

Now we will try to understand how Web Application Server works with database with real life example. Let's assume you want to check your email. You take your computer, open it, start it, and run your web browser. In the web browser, you will type your URL address. As soon as you type your URL address, web browser will now send the request. The request will go to internet by your ISP. ISP stands for Internet Service Provider. Once your request goes to internet, Group Domain Server will now forward that request to Application Server. This Application Server is where your email application is hosted. Application Server will process all the HTML and dynamic pages. The front end of any application is pretty much the same across every single user while using this application. For example, if you are using Gmail, Yahoo or Hotmail, the look and feel will be pretty much the same across every single user of Gmail, Yahoo or Hotmail. However, their emails will be different, the data will be different. You will have data from your friend and other users will have data from their friends and relatives. Data will differ, but the page will look the same. That's exactly what will happen in Application Server. It will pass the static HTML's and will pass back the dynamic pages through the Application Server. However, every request for data will now go to Database Server. Database Server will have DBMS or Database Management System. Management System will query user data and will give it back to Database Server. Database Server will later pass back the data to Application Server, along with HTML and dynamic page will be returned to internet and at the end will go to web browser of user. It's hard to imagine that there will be any application without any kind of database on the back end. As of 2008, MySQL is the most popular Database Management System on planet earth.

History of Relational Database Model

We noticed that Database Management System plays a very important role in any application. There are two kinds of database models -- Relational Database Model and Non-Relational Database Model. MySQL is a Relational Database Model. Let's quickly see a couple of history bites before we move to understanding relational database management system concept in depth. In 1970, Dr. E.F. Code has developed the concepts of relational database. Any relational database will help following three most important properties. There will be less redundancy between the data, retrieval of the data will be very efficient, and the data modification should be intuitive. Though relational database can get complex, the basic three properties of less redundancy, efficient data retrieval, and intuitive data modification usually stays the same because relational database concepts enforces them. Let's see what are the relational database concepts in depth.

Relational Database Model Concepts

For any relational database model, there are four very important concepts. A model for relational database states the data is storing one or more tables. It also states that each table is two-dimensional. Each dimensions are columns and rows. Intersection of the columns and rows are cells. Let's see them a little bit more in detail. A table: Any relational database consists of one or more tables. Tables are usually modeled after real world entities. For example, an address table would have Address 1, Address 2, City, State, Country, and Zip code or Postal Code. It's quite possible on a single address, one or many different persons are staying. It's quite possible that there is nobody staying at the address as well. Address can have different types, like Work, Home, Factory or Open Ground. Well, all of them can be tables. A column: A column represents some attribute of the entity of the table. For example, in the case of the address, as we discussed, it can be Street #, Apartment #, Address 1, City, Zip code or any other detail. Columns are also known as fields. A row usually contains a set of values for a single instance of entity. For example, in address table it will have a single address. A single address may contain multiple columns. An address can be Apartment #, followed by Street #, followed by City, State, and Zip code. If the table has multiple Countries data, then there may be an additional column for Country and the row will contain Name of the Country. Well, this discussion leads to our last discussion about cells. Cells are nothing but intersection of row and column. One cell may contain Apartment # and another cell may contain Street #. They can belong to different columns and they can belong to different rows. It is just an intersection and each of the cells will have a single value. Well, think about it this way. Apartment # may be a number, but street name may not be a #, but may be a string. Now we are leading to another concept that cell can have different kinds of value. It can be a number or it can be a string or it's quite possible it's a mix of both of them. In relational database, everything into the table has a relation to each other, as well as there is a relation among the tables. Well let's see that in the next clip.

Relational Database Model Keys

The most important part of any relational database model is relations. In relational database, there are always relations between various tables, as well as columns of different tables. They are associated with each other with Primary Key, as well as Foreign Key. Primary Key: Primary Key uniquely identifies each row of the table. There can't be more than one Primary Key per table. The most important property for Primary Key is that it cannot allow any NULL. It's not necessarily that Primary Key has only one column, there can be more than column for Primary Key as well. When there are more than one column builds of Primary Key, they are called composite columns. Let's try to understand what can be a good candidate for Primary Key. Let's assume that you have a table called Student. In a table Student, Student ID will be a good candidate for Primary Key. If you have a table called Supplier, in that case, you can also go with Supply Name as a Primary Key as well. In your system, you don't want two suppliers with the same name; however, you have any reason you have two supplied with same name and your system requirement is to allow that, you might have to add another column, which we call Supplier ID. Instead of identifying each row with Supplier Name, now you have identified each row with Supplier ID. Now think of it, what could be the reason that you have a same name for two different suppliers? It's quite possible both of them are supplying different things; one is supplying pencils and another one is supplying erasers. In that case, you have two options. Either you add Supplier ID, which I would prefer or you can create a composite column as a Primary Key. You can use Supplier Name and Supplier Item as a composite Primary Key. Personally, I would add Supplier ID. The same Primary Key will be also another column in another table where we will have Foreign Key relationship. A narrow Primary Key translates to less random data and eventually leads to higher performance. Well, we'll talk about this thing with an example in our advanced course, but for a moment let's assume that you have created Supplier ID as a Primary Key; however, you still want every supplier's name unique in the system. What should be the workaround for that? Well, the workaround is to create Unique Key or Supplier Name. Unique Key is not a Primary Key; however, it still ensures the data is not duplicated. You can have multiple Unique Keys in one table. Unique Key also allows one NULL, whereas Primary Key does not allow any NULL. We talked about Foreign Key a little bit earlier. Foreign Key: Foreign Keys are the columns in a table that refers to Primary Key of another table. Let's assume that we have a table called Purchase Order. In the Purchase Order table, we will have Supplier ID. Supplier ID will have a Foreign Key relationship with the Primary Key of Supplier table. The primary responsibility of Foreign Key is to enforce referential integrity throughout the database. There can be different kinds of relationships between Primary Key and Foreign Key. There can be one-to-one, one-to-many or many-to-many relationship. Let's understand one-to-one relationship. Here, we have Person and Address. One person has one address and one address has one person. This is a one-to-one relationship. However, it can go complex. One person might have multiple addresses. He might have billing address and mailing address, as well as his office address. Now, a person has multiple addresses, that is a one-to-many relationship. Let's look at the same example a little differently, one-to-many again. This time, there is one address and there are multiple persons staying at that one address. Isn't that the case in our home too? We have multiple people staying at one single address. Let's go a little bit more real, many-to-many. Some might have a one-to-one relationship with one address and it's quite possible that certain place, one address might have multiple people staying there, and it's also possible that all three of them working at the same place. This is a great example of many-to-many relationship. Here, the office address has a three-relationship, whereas one home address has a one-relationship, and another home has a two-relationship. The primary task of relational database is to retrieve data efficiently from this various relationship and have less redundant data stored in database.

Column Definition

Column definition is very important. We create Primary Key, Unique Key, Foreign Key, and Indexes on column. Column definition is very critical when we talk about performance. In column definition, data type determines the type of information we store in column. For example, we have various kinds of data types -- string, integer, float, date and time. We can store any character string in CHAR or VARCHAR data type and then store any numeric value in integer data type. If you have decimal value, we can put them in a float and if we have date data type, for example, birthday or anniversary date or joining date, we can use date and time date data type. Along with data type, there are a few important properties of column definition as well. Let's look at them. Default Value. We can specify a default value for any column. Let's see a scenario where you have a requirement to log current date/time of data inserted into a table. You can create a column with the name ‘insert a date' and by default give it a value of ‘current date/time'. What it means is that every single time any data, which is inserted into that table, the column ‘insert a date' will be automatically populated with default value, but not every column qualifies for default value. There are cases where you may not know what to put in a column. At that time, you can leave the column as NULL. This is called NULLable column. Now, you can have a default value in the column or you can just leave the column NULL and there won't be any data there. You can later go and update either this default value or NULL value. Auto increment column: Auto increment column is a column which is continuously increasing by the interval, which we specified in the column definition. Auto increment column is very important because in many cases it is difficult to identify column qualifying for Primary Key. In that case, we can add an auto increment column. Now, auto increment column will not have a NULL value. Additionally, it will be always incrementing distinct value. This is a good candidate for Primary Key. Personally, I believe defining column data types and column properties is one of the most essential tasks for any database designer. With this, we complete understanding of our last concept in Fundamentals of Database Design.

Summary in Sixty Seconds

Summary in Sixty Seconds A relational database consists of tables. A table consists of Rows and Columns. The intersection of Rows and Columns is called cell. Primary Keys uniquely identifies each row of the table. Foreign Key enforces referential integrity. Defining data type of the column is one of the most crucial tasks of database modeling. Check out other database designing courses on Pluralsight.

Introduction MYSQL Workbench

Introduction

Hi, this is Pinal Dave for Pluralsight. In this module, we will understand how MySQL Workbench works and various features of it. In an earlier module, we had a little bit introduction to MySQL Workbench. In this module, we will understand MySQL Workbench a little bit more in depth. Now, the next logical step is to learn about coding and building the database. However, before we move to that one, we need to learn about how we can use MySQL Workbench efficiently to build a work database. MySQL Workbench is a Visual Database Design Tool. It is a three main workspace. One is Development, second is Design, and third is Administration. In this module, we will understand each of them a little bit; however, we will spend more time on development-related features of MySQL Workbench.

MySQL Workbench Features

MySQL Workbench feature list is very long. It will be impossible to cover every single feature in this module. We will be covering the features which we are going to use in this course, as well as the essential feature, which is important to do any task in your daily job. MySQL Workbench features can be divided in following areas: Database Development, Database Designing, Database Administration, Database Migration, and Miscellaneous. You can see that MySQL Workbench is very feature-rich and pretty much you can do every single task, which you need to do with MySQL Database. In Database Development Area, you can do schema browsing, syntax highlighting, addition or update to the result set, as well as it contains efficiency tool of snippets. Database Designing, it is a very critical task for any database developer. MySQL Workbench offers visual Drag'n'Drop modeling. It also helps to reverse engineering from SQL Scripts, as well as from live database. Schema synchronization and printing of models are also very popular Database Designing features of MySQL Workbench. In Database Administration, one can configure any instance, as well as do account management. You can turn on or turn off any database instance, as well as do log file browsing. Additionally, you can use MySQL Workbench for Database Migration, but you can use any ODBC compliant database to migrate from one database to another database. Well, this was just a list of MySQL Workbench features. Let's see MySQL Workbench into action next.

Starting MySQL Workbench

Now for the rest of the module, we will see demonstration of MySQL Workbench features, which will be useful to us in performing of a daily task with MySQL. You can start MySQL Workbench on Windows platform by going to Start >> All Programs >> MySQL >> (and clicking on) MySQL Workbench application. Upon launching MySQL Workbench, you will see following screen. This is the home screen of MySQL Workbench. On the home screen of MySQL Workbench, we have three major workspaces or sections - First is SQL Development, second Data Modeling, and third is Server Administration. SQL Development is the section where we'll be spending most of our time as this is a SQL Development course. In the SQL Development Area, we can create databases and run SQL queries. In Data Modeling, we will create and manage models. Additionally, we also reverse engineer database. In the Server Administration Area, we can set up various user accounts, browse status variables and server logs. We can also do important export of the data over here. You will also see how we can start and shut down Server in this section. On the top part, you can see Workbench Central. Click on the arrow and it will expand. We have few of the very important links in Workbench Central Area, like MySQL Document Library, MySQL Utilities, Database Migration, MySQL Bug Reporter, as well as Workbench Blogs. Let's start first with SQL Development Workspace.

Demo: Opening a New Connection

In the SQL Development Area, first we will learn about how to open a new connection and start creating a database. Go to the Open Connection screen, click over here. On this Connect to Database screen, we'll be providing a few of the information so we can connect to the database. First, we will give a Host name. I have provided 127.0.0.1 because this is my local host and MySQL Server is installed here on a local host with default Port of 3306. The Username is Root. Now click here for Password. On the Password page, enter the password which you provided and then we install MySQL. Click OK. Now click on OK again. You can see that it has opened SQL Editor for us. Let's go back to home screen before we continue with SQL Editor. Now you've seen here how we can open a connection and start querying, but we are all developers and we know that. There are a few connections, which we like to save and keep on using it again and again. We can also save connections in the SQL Development Area. Let's see that how we can do that. Click on New Connection and it will bring up this screen. Go right over here, Connection Name, and provide information for Host Name, Port, Username, and Password. Click OK and now on this screen, you can also paste connection. Click on Paste Connection and it will show us the status of our connection and click on OK one more time. Now over here you can see the SQLAuthority is a new connection, it is saved. You can double-click over here and it will also open SQL Query Editor. Now we have two tabs in our SQL Editor. First tab, which we opened a few minutes ago and second tab, which we just opened. On the second tab, you can clearly see it is marked with SQLAuthority label. These labels are very important. I've seen an industry that Developer has executed incorrect SQL on a wrong server with the wrong connection. Well, before you execute anything, always make sure the label of the connection is correct.

Demo: Manage Connections

Well, we just noticed that we have created a new connection, which is SQLAuthority. As you keep on using MySQL in your production environment and development environment, you will notice that the number of the connections you work with keep on increasing. At one point, you may want to delete, create or modify your existing connection. You can easily manage all of the connections from your MySQL Workbench. Under SQL Development Area, go to Manage Connections and click over here. It will bring up this screen. You can see on the left side there is a SQLAuthority connection. This is the only connection we have created so far. Let's click over here. Once we clicked, you can see all the information from this connection is filled up on the right side. You can also configure a few of the advanced connections over here by clicking over Advanced Tab. As this is a fundamental course, we will be not spending much of the time on this tab. Let's go back on Parameters. Also on the bottom of the screen, you can see there are a few options -- New creates new connection, Delete deletes existing connection. Let's create one more connection. I'll click on New and new connection is isolated on the left side, as well as it has populated few of the default value on the right side of the screen. Let's give Connection Name as Pluralsight. We'll give Connection Method as a Standard (TCP/IP). In the Host Name, I would reckon leave this one as it is or we can provide Local Host as a Host Name. We'll keep Username, Root, and the Password. Click OK and in this case, we'll also give a Default Schema. We will use Default Schema as sakila. Now, let's click on Test Connection and our test is successful. Click OK and now you can close this one. On the main screen, you can see that now we have two databases, one is SQLAuthority and second one is Pluralsight. Let's change the order of SQLAuthority and Pluralsight in Manage Connection. Click on Manage Connection and now let's click on Pluralsight on the left side in Stored Connection area and click on Move Up. You can see that Pluralsight is now on the top and SQLAuthority is on bottom. Click Close and on the main screen, the order is also changed. Now double-click on newly created Pluralsight connection and you can notice that sakila is highlighted. What it means is that sakila database is now by default selected. Now let's go back to home screen.

Demo: Selecting Data

Now we have seen how we can manage connection, let's see how quickly we can retrieve data using MySQL Workbench from MySQL. Double-click on SQLAuthority. It will open SQL Editor. On the left side, we have Object Browser, right below it we have Information tab. Let's explore schemas. Click on the arrow beside sakila and you can see it lists down Tables, Views, and Routines. Click on Tables and we have various tables listed over here. Right-click on Actors and select first option, which states Select Rows and it will spell out SELECT * FROM sakila.actor in Query Editor and on the Visual Pane we can see the select data. You can see how easy it is to retrieve data from MySQL Database using MySQL Workbench.

Demo: Updating Data

Now we will see how we can use MySQL Workbench to edit table data. On the home screen of MySQL Workbench, go to Edit Table Data. I'll select SQLAuthority as my stored connection and we'll click on Next. Over here, it will give us a few dropdowns where we can select our default schema and tables. I'll select default schema as sakila and table as actor. You can select other table if you prefer. Now click on Finish. Immediately it has opened up table, actor. You can also see name of the table over here, actor. Now let's go to the very first row and you can see the first row is edit table. You can change the value if you prefer. I'll leave this actor_id as 1; however, instead of PENELOPE, I will put over here PENELOPE1. Now click on tab. Instead of GUINESS, I will also put over here GUINESS1. I'll move to line #3 and over here I'll put ED2 and behind CHASE I'll put 2 again. You can see that now I have edited totals. Now you can see on the screen that I have changed PENELOPE to PENELOPE1 and GUINESS to GUINESS1. Do you think this information is committed? What I mean by that is that if I go back and select this data again, do you think I will see PENELOPE and GUINESS or I will see PENELOPE1 and GUINESS1? Well, let's go back and check it in Query Editor. Now to write a new query, go to SQL Editor and click on ‘Create a new SQL tab for executing queries'. It will open Code Editor Tab. Now let's type in a simple query. After selecting the query, click on lightning bolt icon over here. It will execute the selected portion of the script or everything if there is no selection. Click here and you can see the result is now displayed in Visual Tab. On Visual Tab, let's look at the first row. First row says PENELOPE and GUINESS. Remember we have changed them to PENELOPE1 and GUINESS1. We expect to see the changes over here, but they are not over here. The reason is very simple. Let's go back to our actor tab and over here you can still see them, PENELOPE1 and GUINESS1. Though we have changed the record over here, we are not committed yet. What it means is that the data which have you seen as changed is only in the Query Editor. They are still not propagated to an actual database. To apply them to the actual database, you have to select on Apply. You can see on the right bottom screen, there is an Apply tab, which is highlighted. Now let's click on Apply. Apply asks us to give you two updates. You can see over here it has automatically generated two update scripts. One is UPDATE ‘sakila'.'actor' SET where ‘first_name' is PENELOPE1 and ‘last_name' is GUINESS1. When you scroll on the right, you can see it also has a rare condition where ‘actor_id' is = 1. Similar thing is also there for ‘actor_id' = 3. Let's click on Apply. If you do not understand this SELECT statement, don't worry about it. We are going to cover this thing in depth in later modules. Click on Apply and the screen displays Success. Click on Finish. Now you can see the Apply button is disabled. Once again, go to our Ad hoc query, which we have written a few minutes ago and execute it one more time. When you executed over here, you can see that line #1 is now changed from PENELOPE and GUINESS to PENELOPE 1 and GUINESS1. Similar thing for line #3, it's also ED2 and CHASE2. We have learned that how successfully we can edit the row in any table using SQL Editor. On Visual Tab, you can go to any of the cells and double-click over here. It will make that cell as editable. You can edit the cell and make ED2 to ED and CHASE2 to CHASE. Now you can see once again there is an Apply button and a Cancel button. Apply is highlighted and if we click on Apply, the ED and CHASE will be committed and it will be communicated to the database. If you don't like the changes which we have done, we can easily click on Cancel and you can see they will revert to their original value. SQL Editor is very powerful. We can also edit it one more way. Click on any line and now go to Edit in the Result Tab. Click over here and now that particular cell and complete row is editable. The logic of Apply and Cancel remain the same in all the cases. In this clip, we have learned three different ways to edit any row in SQL Editor.

Demo: Open and Execute SQL File

Now we will see how we can edit SQL Script in SQL Editor. Go to MySQL Workbench home screen. Click on Edit SQL Script. Let's select SQLAuthority as your Stored Connection and click on Next. Over here it will ask us ‘Please select SQL file you want to open'. I already created a SQL file, which I'll select from this Browse menu. I selected the file ‘Test1.sql'. There is an option if I want to execute this file upon opening. I'll select this one as I know this one is safe to execute. I strongly recommend that don't select this checkbox if you are not sure about the content of the file, which you are opening. Now click on Finish. It has executed the SQL, which was part of TEST1.sql. In the TEST1.sql, I had a very simple SELECT statement. It was SELECT * FROM sakila.actor. It will list us all the actors. Let's write another SELECT over here and now we will save this file. Let's close TEST1 and now we will open the same file once again. Go to ‘Open a SQL script file in a new query tab' with a second option in Menu over here and open TEST1 once again. You can see that TEST1.sql now has two SELECT statements. Let's execute them together. Select these two statements and click on Execute. Now let's look at our Visual Pane. On Visual Pane, you can see there are two tabs also over here. One is actor 1 and second one is city 2. One and two is just indicating the order of the query, how they're executed. They are just an indication. You can reorder them as well. Actor is now listing all the actors and city is now listing all the cities. Working with SQL Editor is indeed very easy.

Demo: Inserting Data

Now we will learn how we can insert a new row using SQL Editor. Go to Schema or database sakila, click on Tables, right-click on Actors, and select ‘Select Rows'. It has written us rows from table, actor. Now on the Visual Tab, you can see on the top bar there is a menu. The first menu states ‘Edit current row', which we have seen it earlier, and now go to the next one. There's a small plus sign on table grid there. The pop states ‘Insert new row'. Click over here. At the end of the table it has given us a new row. Here I'll insert a new id, 1000, name is Pinal, last name is Dave, and last updated date, let's put any date. Now the logical Apply and Cancel is still there. Click on Apply if you want to insert this row. I'll click on Apply and it has automatically generated INSERT script for us. Now you can see the INSERT script has been generated. You can see the values when you scroll down the right side. Now click on Apply and click on Finish. Now you can see Apply and Cancel at this table. If you go to the end of it, you can see the new row has been inserted. In the next clip, we will see how we can delete the newly inserted row.

Demo: Deleting Data

In this clip, we will see how we can delete any row using SQL Editor. We'll be deleting the row, which we have just inserted in the previous clip. Click on the row which you want to delete and once, again, you go to the menu of the Visual Pane. Beside the ‘Insert new row', there is a minus sign over the grid. Click on this menu icon and you can see the row has disappeared. Click on Apply. You can see the SQL for DELETE is generated. Click on Apply again and it has applied the SQL script to the database. Click on Finish and let's scroll down and this time Apply and Cancel are visible. Now you can see how easy it is to select, insert, update, and delete rows in my SQL Workbench.

Demo: View and Edit Column Definition

Now we will see how we can view and edit column definition in SQL Editor. Go to SQL Development Area. Click on your server and it will open SQL Editor. We will be using sakila simple database for this example. Let's expand it and further expand Tables section. On the very first table, which is actor, right-click over it and now click on Alter Table. Alter Table will open up this screen where we can complete table definition. We can see there are four columns over here -- the actor_id, first_name, last_name, and last_update. Additionally, we can see each Column Name's Datatype as well. Actor_id is SMALLINT, first_name is VARCHAR, last_name is VARCHAR, and last_update is a TIMESTAMP. If you remember, we talked about there are various properties of Column. Now we can also set them over here. First column, PK stands for Primary Key. Actor_id in this table is a Primary Key. The second column is Not Null column. You can see that actor_id, first_name, last_name, and last_update are Not Null columns. The next column UQ stands for Unique Index. There is no Unique Index in this table. BIN stands for Binary. If any of the column was binary, the checkbox in front of that column would have been selected. UN stands for Unsigned Datatype. In this case, small integer is Unsigned Datatype. Also, there are two additional properties, which we have talked earlier. One of them was Default Value. You can also select Default Value over here. ZF -- ZF stands for ‘Fill up value for that column with 0 if it is numeric'. If any of this column is numeric, we can just select this particular column and it will automatically default it to 0. AI stands for Auto Increment. In this case, the first column, actor_id, it is also a Primary Key and it is also auto incremented. If you remember, in a previous module we talked about most of the time the column which is auto incrementing is a good candidate for Primary Key. If there is any other Default Value, we can also specify them over here. For example, in the fourth column, which is last_update, we have a TIMESTAMP datatype and it is Not Null and the Default Value is CURRENT_TIMESTAMP. What it means is that when we insert any row in this table, if we do not specify what data goes to last_update, we will automatically assume CURRENT_TIMESTAMP value, which is current date/time. You can further see the translation of each of these columns in this area. If you carefully look over here, you can see there are other tabs as well. The Index tab talks about what kind of index exists on this particular table. We can also create new indexes, as well as delete indexes over here. We can use this Foreign Key tab to define Foreign Key between this table and another table. If there are any triggers, they will be listed over here and we can further modify them. If the table is partitioned, you can see the logic over here. We will talk about partitioning in Administration Course and on the last tab, we can set up various different values for Table. For example, here we can specify the Auto Increment Value. This is the new initial Auto Increment Value for the table. If you have 1000 record in this table, the next record will be 1001 and remember to click on Apply if you want to commit any changes you do with table definition.

Demo: Creating Snippet

Now we will see how we can use Snippet in MySQL Workbench. Snippets are nothing but a library of SQL Syntax. No matter how expert you are writing SQL queries, there are always moments when we don't remember what was the exit syntax of a particular feature. To enter the Snippet Area, go onto MySQL Workbench on the further right-most icon over here. Click here and it will open up Snippet Area. Let's see a few of the Snippets. Double-click on SELECT Syntax and you can see the SELECT Syntax is given over here. You can either edit this one and write new syntax over here and click on Done. Similar way, we have a JOIN, INSERT, UPDATE, DELETE, and REPLACE Syntax. Let's try to create a Snippet for selecting data from a table. I'll write down syntax over here, which is SELECT * FROM. Now I will select this one and click on Add snippet. When I click on this one, you can see there is a new entry over here. Now double-click on it and you can see the selected text is visible here, which is SELECT * FROM. Now click on Done again and now type any schema name followed by a table name. For example, sakila.actor. Now right-click over the snippet and select ‘Insert snippet text' at the cursor and you can see it automatically populated SELECT * FROM and table name, which we had already written. You can just click on SELECT and now it will display the data. This is how you can use snippet to expedite writing your SQL queries.

Demo: Output Window

Now we will see one more feature of MySQL Workbench, which is Output Tab. In the SQL Editor, go on the top and select on second-most, which you see over here. You can see it has brought up Output Tab without any data over here. Let's go to sakila database and right-click over actor table and Select few Rows. Output Tab displays us any query which we have executed along with any message. If you have done any syntax error, we can also see that in our Output Window. For example, here insert a FROM, I will write FROMs. Now let's execute the whole query again. You can see that the query is not correct anymore and an error is displayed over here. Error Code 1064: You have an error in your SQL. Now let's go back to Home Page.

Demo: Data Modeling

So far we have been seeing features from SQL Development section. Let us see how Data Modeling section works. We'll create an EER Model from existing database. Let's click over here and select our preferred connection. I'll select SQLAuthority, click on Next, and it has successfully connected to DBMS. Additionally, it has also retrieved schema lists from database. Click on Next and you can see all the schema which exists in MySQL Database. Let's select sakila and click on Next. You can see on this screen that it has successfully retrieved all the object from sakila schema. Click on Next. On this page, it is asking us, what are the objects which we want to use for reverse engineering? We can select Tables, Views, Routines, and Trigger. Just for this example, I will leave all of them checked and click on Execute. You can see that it has successfully executed reverse engineering task. Click on Next and we can see the Success Message. Now, for last time, click on Finish. Here is our EER diagram. Well, currently all the objects are over each other. Let's select all of them by typing CTRL A. Now go to Arrange and click on Autolayout. It will automatically layout each of these tables, along with their relationships. Let's go to city table and click on Indexes. Click on Indexes and you can see there is only a Primary Key over here. EER diagrams are very interesting to read. Let's go back to the main screen of MySQL Workbench.

Demo: Server Administration

Now let's understand a couple of important features of MySQL Server Administration. Double-click on the connection, which we have already created, and it will open Server Administration Area. On the top of the screen, it displays Server Status. You can see in this INFO section that the name of our Server is SQLAuthority and it is running on a Local Host. Additionally, resin of the Server is also 5.6.10. The status of our Server is Running. On the very right side, you can see the system has both CPU and memory. MySQL Server Health is also displayed right beside it. Connection, Traffic, Query Cache Hit Ratio, and Key Efficiency are displayed here. We can quickly see them and get an idea of how Server Health is. Also, you can see there are four different connections and each connection has a different state. One connection has a Query and the other three connections are right now in the sleeping state. If there is Query, which is taking a lot of resources, you can either kill the query or can kill the complete connection as well. Right below Server Status, there is Startup and Shut Down option. You can stop your MySQL Server from here, as well as start it. Let's stop our server and start again. Currently, the Server Status is Running. Click on Stop Server and now you can see the server instance is stopped. If you want to start the server instance back, you can just click on Start Server and it will turn on MySQL Server instance. You can use this administration screen to do a lot of other tasks as well. For example, you can collect Status and System Variables or you can see Server Logs. If there are any errors, you can find them over here. Additionally, you can configure MySQL Administration's lots of variable over here. There are many important settings in this Configuration Area. In MySQL Administration course, we'll go over each of these options and their significance. We'll discuss about Logging, InnoDB, Networking, Advanced settings, Other settings, Security-related settings, Application, MyISAM, and Performance-related settings. I often see developers working hard to tune the SQL queries; however, they absolutely ignored this Performance Tab in MySQL Administration. There are many options available in this Configuration Area, which can immediately impact performance very positively. This Server Administration Area also gives you fine control on your Users and their Privilege. You can take a backup and export to database or import your database and restore your MySQL Database from this Data Export/Restore section. Let's click on Home Tab and go to the main screen of MySQL Workbench. Well, with this, we'll finish our introduction to MySQL Workbench.

Demo: Workbench Central

Now we understand the three major sections of MySQL Workbench -- SQL Development, Data Modeling, and Server Administration. Now we will understand Workbench Central. Click over here and you can see there are various links for Workbench Central. The first one is MySQL Doc Library. Click over here and it will open MySQL Documentation. You can pretty much search anything over here and this is a great reference. For example, let's search for ‘alter index' and when we search for alter index, it gives us 24 matches and all of them showed up instantaneously. Let's do another search. Let's search for ‘create database'. There are more than 50 results for ‘create database'. If you are doing MySQL code and if you're stuck, I strongly encourage you to refer to MySQL Workbench Reference Manual. There is a good chance that it will solve all of your problems. Let's close this and go to Home Page. The second link over here is MySQL Utility. When we click over here, it displays us a list of MySQL Utilities. They are very important. For example, there are utilities for identifying difference, auditing administration or doing import or export. Let's close it and here is the link for Database Migration. When you click over here, it opens MySQL Workbench Migration Wizard. This wizard assists us in migrating table and data from supported database system to MySQL. You can also use this one to copy database from one MySQL instance to another MySQL instance. Let's close this one. Similarly, we can submit MySQL Bug from MySQL Workbench itself, as well as for additional tips and tricks, we can read Workbench blogs. Now we are back on the main screen of MySQL Workbench. With this, we conclude this module and move to Summary.

Summary in Sixty Seconds

Summary in Sixty Seconds MySQL Workbench is divided into three major sections: i)SQL Development, ii)Data Modeling, and iii)Server Administration. We can retrieve, view, edit or delete data from SQL Editor of SQL Development section. We can create database model, as well as reverse engineer database from Data Modeling section. We can start, stop, and manage MySQL instance from Server Administration section. Remember, we can use MySQL Command Line Editor if we have no access to MySQL Workbench. You can download MySQL Workbench from the URL displayed on the screen.

Data Retrieval Techniques

Introduction

Hi, this is Pinal Dave for Pluralsight. In this module, we will discuss about various Data Retrieval Techniques. For any IDBMS, data retrieval is the most essential task. In an earlier module, we learned we can use MySQL Workbench to retrieve and modify data. MySQL Workbench is a great tool for developers who have to deal with the data. For any application, you have to write scripts in SQL to retrieve or modify data. SQL stands for Structure Query Language. In this module, we will learn how to code SELECT statement and retrieve data. It is very important to have proper understanding of how SELECT statement works and its building blocks. All the concepts, which we learn about SELECT statement, applies to update and delete statements, which we will explore in the next module of data modification. Let's start to understand the basics of SELECT statement and it's most essential building blocks -- WHERE, ORDER BY, and LIMIT.

Basics of SELECT statement

Developers use SELECT statement for various purposes. Here is a list of few of the examples where we use SELECT statement: Retrieve static value, retrieve all the data from table, retrieve all the data ordered by single column, retrieve selected columns from table, retrieve data with filter condition, retrieve the data with filter condition and ordered by multiple columns, retrieve empty resultset. In this module, we will see examples of this, as well as a few real-world scenarios. Let's start with understanding basic syntax of SELECT statement. A basic SELECT statement has five clauses. SELECT clause: It describes the column in resultset. FROM clause: Names the base table from which the query retrieves data. We can also use views here, but that's advanced concept. WHERE clause: It specifies the condition that must be met for any row to be retrieved in resultset. ORDER BY clause: It specifies how to sort the rows in resultset. We can have one column or multiple columns, by which we can order resultset. LIMIT clause: It specifies the number of the rows to return. Sometimes tables are very huge and it's important that we retrieve only a limited number of the rows for various reasons. In Basic Syntax of SELECT statement, we have not included all the clauses in this Basic Syntax of SELECT statement. For example, HAVING clause: HAVING clause filters data based on aggregate functions. In our advanced course, we will be talking about aggregate function. At the same time we will explore HAVING clause and also understand difference between WHERE clause and HAVING clause. Now let's see SELECT statement in action.

Setup for demo

Before we start with our demonstration, let's understand the setup required. You will need MySQL Server, MySQL Workbench, and Sample Database sakila. In my case, I'll use MySQL installer for Windows and in this case, by default, install MySQL Server, Workbench, and all the necessary Sample Database. You can use either of the method, but make sure you do practice all the demos, which you see in this course. Now, open MySQL Workbench, click on your server name, and it will open SQL Editor. This is the screen where we'll be starting most of the demos. On the left side on Object Browser, you can see we have sakila Sample Database installed. Most of the demos of this course will begin with this screen.

Beginning SELECT statement

Now, let's see some of the SELECT statement into action. We will go over some of the basic and simple SELECT statements in the beginning, later we will see more complicated examples. First, we will see how we can use SELECT statement to retrieve static values. Later, we will use SELECT statement to retrieve all the data from table using star. The same retrieved data, we will order by single column. Later, we will only select selected columns instead of all the column from the table. Right after that, we will make sure the data, which we will retrieve, is not all the data. We will write a filter condition on the top of the SELECT statement and retrieve only selected rows. After that, we will combine all of our learning and retrieve data for selected column using filter condition and with order by multiple columns. Finally, we will see a simple trick where we will retrieve empty resultset using SELECT statement. Now let's see a demonstration where we will see each of them in action. Now let's open MySQL Workbench.

Demo: Select without FROM clause

Well, open MySQL Workbench and let's start with simple examples. As discussed in an earlier set of clip, you just need sakila Sample Database, MySQL Workbench, and MySQL Server. Let's start coding together. Let's type ‘SELECT MyFirstValue'. MyFirstValue is a string and let's select that and see what result comes up. Click on Execute and you can see MyFirstValue is now displayed over here. The name of the column is same as the value as we have not specified any alias. Let's type alias ‘AS SomeValue'. Now let's execute the same thing again and you can see name of the column is now SomeValue and value is MyFirstValue. Similar thing you can do with arithmetic operations over here. SELECT 1+1 and let's see the fun. You can see that value is now 2 because 1+1 is 2; however, name of the column is 1+1. Let's give it alias over here ‘AS TWO'. Now let's execute it one more time and you can see now name of the column is TWO and the value is also TWO. In MySQL, you can also get current date/time by using function NOW. Let's learn SELECT NOW. The result displays with current date and time. If you just want only date part and not the time part, you can just write ‘SELECT CURDATE'. Let's execute this and you can see only date part is displayed and time part is not displayed anymore. If you want only time, similar way you can write ‘SELECT CURTIME' and it will display as current time and date part is not displayed. You can also display the value of pi by using ‘SELECT PI' files in BUILD function. Let's execute it and you can see the value of pi is displayed here, 3.141593. Well, you can do other mathematical functions as well, like finding remainder. When you divide 45 by 7, what will be the remainder? Well, let's learn ‘SELECT MOD(45,7)' and it gives us remainder as 3. Another interesting function would be to just find square root of any value. Here, we have specified 25 and square root of 25 is 5. Let's execute this and you can see it has found square root of 25, it is 5. You do not need FROM, WHERE, ORDER BY clauses if you are just doing some simple operations.

Demo: Retrieve all the data from table

Now we will see how we can use star and retrieve all the data from the table. Here is an example, ‘SELECT * FROM sakila.actor'. When we use a star and do not provide any filter condition using WHERE, this statement will retrieve every single column and every single row from sakila.actor table. Select the statement and click on Execute. You can see it is retrieving all the four columns and all the 200 rows from sakila.actor table. Let's take another example. We can also retrieve all the rows and all the columns from sakila.city table. Select the statement and click on Execute. Well if you noticed, we are using sakila.city name. This naming convention is database.tablename. If you don't want to keep on using sakila in a name of this table, you can use another technique. For example, here I'm using ‘USE sakila'. When we execute this statement, it will by default sakila database as a database for every subsequent execution of statement. Let's see that into action, but first, pay attention on the left side in Object Browser. You can see sakila, test, and world, all three have similar fonts. Now, let's execute ‘USE sakila'. When you execute this one, at that time, now sakila is highlighted or bold. What it means is that now sakila is default context for every single execution after this statement. When we execute this one, it will retrieve as same data, which we got from ‘SELECT * FROM sakila.city'. USE database name is a good idea to execute if you know every subsequent execution you are going to do from same database. Let's close this and now in the next clip, we will retrieve all of the data ordered by single column. (Typing)

Demo: Order data based on a column

Now we will see how we can retrieve all the data ordered by single column. For example, here is ‘SELECT * FROM sakila.actor', which we have just sent. It has four columns -- actor_id, first_name, last_name, and last_update. Quickly glancing at resultset, we can see that first_name column is not ordered alphabetically, so is last_name. We can quickly order first_name in alphabetical, chronological order if we write ‘ORDER BY first_name' right after SELECT statement. Let's select this statement and execute it. Now we can see that first_name is chronologically ordered, ADAM is first, ZERO is at last. Interesting enough, the name of actor is ZERO. Similar way, we can order the same table with last_name. Let's execute this statement. Now you can see that the complete table is ordered by last_name column. A is on the top and C is at the bottom. Well, currently we had just seen them in alphabetical order; however, the order is ascending. We can also change this sequence order by just adding DESC clause. Let's execute this first statement where we have first_name as descending in ORDER BY clause. When we execute that, we can see now ZERO is on the top and ADAM is on the bottom. What happens here is that by adding ORDER BY, column name, and DESC clause, now entire table is ordered descending by first_name column. We can do similar thing with last_name as well. Let's execute this statement and now, entire table is ‘ORDER BY last_name DESC'. ORDER BY clause is very handy and very easy to use. Now in the next clip, we will see how we can retrieve selected columns from table.

Demo: Retrieve selected columns from table

So far we have been retrieving all of the columns and all the rows from the table. Now we will see how we can retrieve only selected columns instead of retrieving all the columns. For example, let's see ‘SELECT * FROM sakila.actor'. There are four columns -- first is actor_id, second is first_name, last_name, and last one is last_update. Now it's quite possible not everybody needs last_update data. Some people may only want to see first_name and last_name. Well, we can do that very easily, instead of writing *, we can just write first_name and last_name and select data from this table. We will write SELECT first_name, last_name FROM table name, which is sakila.actor. Let's select this and execute. Now you can see we are getting data from only two columns, which first_name and last_name. There are many reasons to spell column names instead of writing *; however, the primary reason for that is performance. Additionally note, the data which we retrieve for first_name and last_name is not in order. If you want to order them, we can just specify ORDER BY clause over here. In this case, I'm specifying ‘ORDER BY first_name DESC'. Let's select this statement and execute it. Now we have first_name and last_name column, ORDER BY first_name DESC. In this example, we have seen how we can filter columns and retrieve only the columns which we need. In next demonstration, we will see how we can further filter rows as well.

Demo: Retrieve selected columns and rows

In the real example, we filter columns; in this example, we will filter rows. ‘SELECT * FROM table name' retrieves every single row and column from table. You can see that in this example where I'm retrieving all the data from sakila.actor table. Here, let me introduce a new clause, which is WHERE clause. WHERE clause is nothing but condition. In later part of this module only, we will understand WHERE clause in detail; however, this is a simple example. Let's write the statement from the start. SELECT * FROM sakila.actor; what it means is that now we are going to get every single row and every single column from sakila.actor table. Now, let's read the next line, ‘WHERE actor_id > 100'. What it means is that now we will only retrieve from sakila.actor table, those rows where actor_id is greater than 100. Currently, our sakila.actor table has 200 rows. Now we are talking about retrieving rows only where actor_id is greater than 100. Let's select this statement and execute it. You can see that in the result, our data starts from actor_id 101. Let's quickly scroll down and see if there are any data which is less than 100. A quick inspection demonstrates that there are no rows which has actor_id greater than 100. What it means is that this WHERE condition has filtered out row where actor_id is 100 or less. Now let's change this greater than to less than and see what result it brings to us. After executing, we can see that we have actor_id 1; however, let's see what is our maximum actor_id. The maximum is 99 because here, we have WHERE condition where we have specified that ‘WHERE actor_id < 100'. You can notice that writing WHERE condition is very simple and it's very intuitive. Let's see the next example. In this example, now we are filtering out fourth column, which is last_update. We are only selecting actor_id, first_name, and last_name. We have changed here the WHERE condition, now I'm mentioning WHERE first_name = ‘Nick'. What it means is that now we will enter only those rows, WHERE first_name = ‘Nick' from the table sakila.actor. Let's select this statement and execute it. We can see there are three records over here. All three records have first_name as ‘Nick'; however, last_name is different. Additionally, the fourth column of last_updated is also not visible over here. It was very easy to see how we can filter rows and columns. (Typing)

Demo: Bringing it together

Now we will further continue our same example and see how we can filter columns, filter rows, as well as order record set with multiple columns. Let's start with a very simple example. Here, we have SELECT * FROM sakila.actor WHERE first_name = ‘Nick'. As we have seen, we are going to get four columns because there is * and three rows because we have first_name = ‘Nick'. Let's execute it and, as expected, we can see now four columns and three rows. Let's assume that we don't need last_update column. Well remove that. Now we will not use *, instead of that we'll specify actor_id, first_name, and last_name. While we do that, we'll also add one more twist. Currently, we are getting our data, which is this spot, actor_id ascending. Let's change the sequence and we want now data, which is ‘ORDER BY actor_id DESC'. What it means is that we want our very first record to be 166 and very last record to be 2. We can easily do that if we specify only three columns in a SELECT statement and additionally we provide ‘ORDER BY actor_id (sequences) DESC'. Let's select this and execute. You can see now we are getting 166 as the top record and 2 as bottom record. Currently our result is ORDER BY only one column, which is actor_id. Let's make it more complicated. I'll change the WHERE condition and I'm retrieving, once again, actor_id > 100. Here we have ORDER BY first_name, which is ascending, and last_name, which is descending. Additionally, we have three columns, which is actor_id, first_name, and last_name. What it means is that we have all the elements which we have learned together in this single query. We are filtering by columns; additionally, we are filtering by rows. Also, we are ordering this complete resultset by multiple columns, which is first_name and last_name. Let's execute this and now we have resultset. We can clearly see that every single record in first column actor_id is over 100. Additionally, let's pay attention to the first name. You can see that first_name ‘ADAM' is on the top and ‘WILLIAM' is on the bottom. What it means is that first_name is order ascending alphabetically. However, there is also last_name, which is order descending. What it means is that after the first_name column is order alphabetically ascending, MySQL will pay attention to last_name column. Let's see an example. Look at these two lines. We have first_name ‘GORDON' and last_name is ‘NOLTE' and ‘JACKMAN'. You can see last_name is now order descending because N comes first and J is now coming later on. Here is the example where we have our cell. If you think of alphabets, you can see the B should come first; however, we have ordered last_name descending. What it means is that now D is coming first and later, C and B. So, MySQL has first order complete data as per first_name ascending and later order complete resultset by last_name descending. Let's see a tricky concept next where we retrieve empty resultset.

Demo: Retrieve empty resultset

Let's see a tricky example. I've seen a lot of developer writing SELECT * FROM table name where they just want to see what kind of column table has. When you run SELECT * FROM table, it will pretty much retrieve every single row and every single data from the complete table. This is not a good idea if you just want to know what are the names of the column. The very quick trick would be, over here, is to just write ‘WHERE 1 = 2'. When you write ‘WHERE 1 = 2' at that time, MySQL will not return you any data because 1 = 2 is always a false condition. It's good to understand that you can write this kind of query and get empty resultset. With this tip, we complete our learning of Fundamentals of SELECT statement. In next clip, you will understand advanced concepts related to SELECT statement.

Working with Arithmetic Expressions

Now we will see a demonstration of how we use Arithmetic Expressions, as well as column aliases. By default, MySQL gives column in the resultset the same name as the column in a base table; however, for business needs, we can specify a different name known as column alias. If a column is based on calculated values, by default the name of the column is the complete expression. This automatically assigned expression is usually very difficult to read, as well as write. It's always a good idea to assign the column alias to a column, which either has a calculated value or very complicated name. We will see that in a demonstration later this clip. MySQL values any arithmetic expression from left to right. The order of precedence is as follows: Multiplication, Division, Integer Division, Modulo, Addition, and Subtraction. If you have multiplication and addition in the same expression, MySQL will first perform multiplication and later, addition. When we are reading from left to right, we forget the importance of order of precedence. If you want to avoid confusion, it's always a good idea to use parentheses. Parentheses avoids confusion, as well as gives you expected results. Arithmetic expressions involving multiplication, division, addition, and subtraction are very common. Modulo or remainder or integer division are not commonly used arithmetic expressions. You will see in the next demo, how we can use these various arithmetic expressions in MySQL queries.

Demo: Arithmetic Expressions

Now let's understand the concept of aliases with example. Let's first retrieve a few columns from sakila.rental table. Select the statement and click on Execute. You can see we have retrieved three columns -- rental_date, inventory_id, and return_date. Due to any reason, if you do not like these column names, we can just change them. For changing column names, we just have to alias them. For example, in this SELECT statement, rental_date is original column name. We can just say ‘rental_date AS RentalDate' in the CamelCase and now, this is our alias. Similarly for inventory_id, we are also aliasing it as FilmListID. For return_date, the alias is ReturnDate in CamelCase. Let's select this statement and execute it. You can see in the resultset that original column names are now replaced with column aliases. However, the data which is being displayed right after the header title, it's the same and there is no difference at all. So in other words, aliases is just another name for any of the columns. Well there is not much of the importance of alias at this point of time; however, alias becomes very very important when we are dealing with arithmetic expressions. For example, ‘FROM sakila.film' table, we are retrieving three different columns and two of them have arithmetic operations. Let's select the statement and execute it. You can see the column names are very wide. The most easy way to fix this problem is to just alias a column. Let's see that now. You can see in this example, I have aliased ‘replacement cost -- rental_rate AS CostDiff', length/60 is now alias ‘AS TimeinHour'. Let's execute this statement and you can see that column width is much lesser and it's very easy to read. You can see in this SELECT statement we have used various different arithmetic operators. For example, we have +, *, and -; however, to make this more interesting, I have used parentheses that are in different places. Select this entire statement and now click on Execute. You can see that arithmetic operation on original column changes the complete meaning of the column. Now let's see one more example. Let's select this particular statement and click on Execute. Here, you can see each column has a different value. You can see the original column, replacement_cost, is now aliased with ReplacementCost in CamelCase. Right after that, it is divided by 5. Our result will be decimal. However, if you don't want decimal result, we can just use the word DIV, it will give us integer results. We can also find very quickly, modulo or remainder of any value. For example, here we have value 20.99. When it is divided by 5, we are getting the value as 4.198. When we use the DIV function, it will only give us integer part of this decimal value. In this case, it's a 4; in this case, it's 2; in this case, it's 3. Here, there is a 12.99. When we divide that with 5, our remainder is 2.99. Now you can see how various arithmetic operations come together with the regular SELECT statement and start building intelligent data.

Select statement and other functions

So far we have seen SELECT with aggregate functions, as well as doing some static operations. Now, we will see how we can use SELECT clause with various other functions. For example, we will see functions related to numbers, strings, and dates. One of the interesting challengers we developers have is to eliminate duplicate rows from our resultset. We will see how easy it is to eliminate duplicate rows by adding simple key word, distinct. Now let's go to MySQL Workbench and we will see each of these into action.

Demo: Select statement and other functions

Here, we are back in MySQL Workbench and we will see a demonstration related to integer, string, and date functions. If you see the list of all the functions in MySQL, the list is extremely large. It's just impossible to cover each and every function and explain them in a single clause; however, we'll see a few of the important functions in this demonstration. Once you know how to use one function in SELECT statement, you can go and use any other function in SELECT statement as easily. We'll very first see how integer works. Here is the statement where I'm retrieving data from payments table. Let's first select the data and later we will understand what each of these functions do. Select the statement and click on Execute. Now we can see we have five different columns displayed in our resultset. The very first column is amount. You can see amount is directly retrieved as it is from payment table. We have not modified or applied any function over it. The second column over here is using round function. Round function rounds up or rounds down any of the decimal value to nearest integer. You can see 2.99 is converted to 3 and .99 is converted to 1. If you scroll down, you will see the similar examples over here. In the third column, once again we have used round function; however, this time we are specifying second parameter over here. Second parameter we have passed as 1. What it means is that when you round up or round down, at that time display information to first decimal. For example, over here you can see now 1 is 1.0. To see them further into action, let's take one more example where we will not use any FROM clause, but right of it take integer will do and try to apply round over it. Let's write SELECT ROUND and function. Now let's pass here value 4.5 and let's execute it. You can see it's now rounded up to value 5. If you pass 4.99, it would still round up to 5; however, if you pass 4.49, it will round it down to the 4. Let's go back to our statement and execute it again. Now we'll do one function to look at it. FLOOR rounds down any of the value to the nearest lowest integer, whereas CEILING rounds up any value to nearest high integer. Let's see an example over here. Here, we have a value of 2.99. Then we applied function FLOOR over here. It has rounded it down to 2 and when we apply CEILING function over here, it is rounded up to the 3. Though they look very simple, these are very important functions and comes very handy when we are dealing with numbers.

Demo: Select statement and string functions

In this demo, we will see how we can do some of the very common string operations with string functions. For example, joining two string and making it a single string. One of the most common tasks every developer faces is to concat two strings. For example, if you have first_name and last_name, if you want to display a full name, you just have to concat two strings. MySQL is in BUILD function, which we can use to just concat string. For example, here we have concat function. We can pass multiple parameters over here. I will pass three parameters. First is first_name ‘ ‘ and last_name. Now, let's execute this one. Select the statement and click on Execute. I have aliased the column ‘AS FullName'. Under the FullName column, you can see now first name and last name are displayed together with the space between them. You can see how easy MySQL makes it to join two or more strings. If your need is to just display initial of the person, you can do that using MySQL as well. Here is our second example where I'll use function code LEFT. LEFT takes two parameters, first is a string and second one is how many characters you want to select from the left side. Here I'm applying LEFT function on the first_name, as well as on the last_name, and both the times I'm just selecting one character. When we run this complete SELECT statement, you can see that, along with the FullName, now we are able to see the initials. Currently, initials has a space between them because I have left space over here. If you remove this space and comma and execute it again, you can see that now initial does not have a space between them. Similarly there is a function called RIGHT, which will just select the right-most rows. Currently, we are selecting only one character. Let's make it two for first_name and last_name. Now let's execute it one more time. You can see this time that we are getting first two characters, first_name and last_name. For example, we are selecting PE from PENELOPE and GU for GUINESS. Similar thing is for NICK, we are selecting NI and for WAHLBERG, we are taking WA. As we know, we are selecting only two rows from first initial and last initial, the string which is built for initial has a fixed length. However, in case of the ordering of first_name and last_name, we really do not know what is the length of this string. We can use function LENGTH and can figure it out, LENGTH of our first_name and last_name together. For example, here I'm concatenating first_name and last_name and applying LENGTH function over it. Let's execute this complete statement and here it is. For example, NICK WAHLBERG has 13 characters and JENNIFER DAVIS has now 14 characters. One of the functions is REVERSE. What it will do is that it will take the complete string and display as in the REVERSE order. We can use this function to figure it out while in (inaudible). Let's execute this one. Now in the resultset, the first column is FullName, which is the origin of FullName. You can see NICK WAHLBERG is over, but when we see the reverse FullName, it is now spelled backwards. For example, last character's G is the first character over here and second to last character, which is R, is now second character over here. Let's examine our REPLACE function. For example, in JENNIFER DAVIS, we have S as the last character. When we see the replaced example, we can find DAVI and $ because our S is now replaced with $. Similar thing is also there with GRACE MOSTEL. In this case, S is once again replaced with $. You can use this REVERSE and REPLACE function and can do a lot of different things. Next, we will see function related to date and time.

Demo: Select statement and date functions

Now we will see some of the functions related to DATE. One of the most used function is DATE_FORMAT function. Every country and every geographic region has their own format. When we are dealing with an application which is using a multiple country, we are to carefully pay attention to the date and time. In our daily routine and in our application, we need a different part of the date. Sometimes we need to know date part and sometimes we just need time part. Let's see some of the date and time functions right now. Let's see this very first script. Select the statement and click on Execute and here, you can see the date is first and the month is in the middle. Also, one of the other differences between these two columns is how year is spelled. If you look at the last column, it's also very differently formatted. Even the date and time are the same, the way it is displayed are different. In my circle, we have a different marks for date and time. For example, when we have m, d, and y in the smaller letters, they're each mapped to month, day, and two digit year. If we just capitalize Y, it means now four digit year. Similar way, if you want your month to represent with three-character string, you can just use small b. Capital T stands for the time and F stands for precision of the time. If you search for function date-format in my SQL documentation, you can find details of each and every mask available for DATE_FORMAT. For example, A stands for abbreviated weekday name, whereas small h stands for hour. Capital H stands for now Hour as well, but in 24 hour system. If you want day of the week, you can just use small w and if you want weekday name, you can just use capital W and if you go further up in the MySQL documentation, the 12th section is dedicated to Functions and Operators and over here, you can find out various numeric functions and operators, as well as string functions. Here is the entire list of string functions and operators, which you can practice out each one at a time. Similar way, here is the list of string functions. Let's go to next script. Now we can see that we can change this mask and build the date and time format as we want. Let's go to next script. Here is the DATE_FORMAT. It's quite possible that we are not familiar with each country or each zones. At that time, we can use a very interesting function, which is GET_FORMAT. What GET_FORMAT does is that instead of specifically mask, it will automatically get the format based on your date and time from the zone which you specify. For example, let's execute this. Select the statement and click on Execute. Now we have four columns and you can see on the very first column, if you carefully pay attention to each of these columns, you can notice that they have a same value. The reason is very simple, that GET_FORMAT when we use with the DATETIME for EUR, ISO or USA, it gives us the same time format. Now I replace DATETIME with TIME and let's execute the script again. When you execute the script again, now we can clearly see that all the column has a different information. You can see over here the column #1 and last has pretty much the same information; however, date and month are swapped. In Europe, the date is always first and in USA, month is always first and in ISO format, year in the four digit month and date. Let's first execute this script and later we will understand the output. In our result time, we have five columns. First, is rental_date, which is the original date time and other four columns. The date is 2005-05-24, it was the third week of the day, and it was in the second quarter, as month is May. This particular month was 21st week of the year. Well, MySQL has a default function where it will give you day of the week, quarter of the year, week of the year, and name of the month. You can just use any of these functions and pass your DATETIME as one of the parameters, it will give you the output, which you are expecting. With this, we end our clip, but you can notice that how easy it is to use various function in a SELECT statement and can get desired output.

Demo: Select statement and distinct rows

Now in this demonstration, we will understand how DISTINCT keyword impacts query resultset. Before we execute query, let's look at the Output Window. Go over here in MySQL Workbench and click it here to display Output Window. We'll first execute SELECT first_name FROM sakila.actor. Select the statement and click on Execute. You can see the resultset over here, as well as can notice there are 200 rows returned from this query. Now we will execute second query. The only difference between first query and second query is DISTINCT keyword. We have additionally added DISTINCT keyword because now we want unique first_name from sakila.actor. Let's execute this one and this time, you can notice that we only receive 130 rows. What it means is that there were 70 records, which were duplicate. Now duplicate records are eliminated and we can only see DISTINCT resultsets. Let's run it again for last_name. Select last_name from sakila.actor and click on Execute. From resultset, you can clearly see that ALLEN last_name is there multiple times, as well as BERRY. Now we will learn another SELECT statement where we have DISTINCT keyword right before the last_name. Select the query and click on Execute. Now ALLEN is only displayed once, so is BERRY. If you look at the Output Window, we can see that when we selected last_name from sakila.actor, at that time MySQL returned 200 rows. However, as soon as we added DISTINCT keyword, it has returned us only 123 rows. We can use DISTINCT with multiple columns, as well as with star. The purpose of the DISTINCT is to return unique rows based on the column used in a SELECT statement.

Introducing WHERE clause

Performance is a very crucial dimension for any application. So far, we have seen in most of the cases, we are retrieving pretty much entire table for our purpose. For that, we use SELECT * FROM table syntax. We also learned that we should not retrieve columns, which we are not using in our application and use column names in the SELECT statement instead of using SELECT *. There should not be a need of all the rows of the table. Most of the application in most of the cases needs only subset of the rows from the table. We can limit the number of rows, retrieve by query by using WHERE condition. It is important that we understand how to use WHERE condition very carefully as it will help us tremendously when we are dealing with very last table and we want to retrieve only rows, which are required. Let's understand a few of the conditions, which we can use in our WHERE clause.

Select statement and Comparision Operators

Now we will see how we can use various Comparison Operators into WHERE clause. We can use comparison operators to compare any two expressions. MySQL is good at converting data for comparison; however, it's always a good idea to have both the sides of comparison operators to have the same data type. If the result of the comparison is true, the row being tested is integrating query resultset. If the result of comparison is not true, the rows are not included as a part of resultset. If you are comparing numeric value, we will not need single code. If you are using string, date or similar kind of data type, we may have to wrap our value with single code. You will see that and understand that into demonstration. Let's see the list of various comparison operators: Equal, Less than, Greater than, Less than or Equal to, Greater than or Equal to, and Not equal. Let's see all of them into action.

Demo: Comparision Operators

Here we are in MySQL Workbench in SQL Query Editor. Let's see some of the examples how WHERE clause works with comparison operators. First, we will see how equal operator works with integer and string. We will be using sakila.actor table for this demonstration. Let's not select the WHERE clause and select SELECT column name FROM sakila.actor. Click on Execute. We can see that it has returned us entire table. Let's also enable Output Window. In Output Window, we can see it has returned us 200 rows. Now, let's execute this entire query with WHERE condition where ‘actor_id = 100'. Select this row and click on Execute. You can see in Output Window it has retrieved only one row and the row is ‘actor_id = 100'. Instead of selecting entire table, we should be passing WHERE condition and select the row, which is needed. Here, we are comparing column name with string operator. As mentioned earlier, for integer you do not need a single code around it; however, for string, you need a single code around your parameter. Now let's select this query and execute it. You can see in result pane it has retrieved us three rows and similar results are also reflected in our Output Window. This query has returned us every single actor where first_name = ‘Nick'. The implementation of comparison operators ‘equal to' is pretty straightforward. Now we will see how operator ‘less than' works. Instead of using equal, in the WHERE clause I have used ‘less than'. What it means is that now we will get all the actors who have ‘actor_id < 100'. Let's select this query and Execute. Now we have 99 rows and when we take the actor_id in resultset, you can clearly see that it is less than 99. None of the actor_id is over 100. This is how we can use in our WHERE condition ‘less than' operator. Let's execute this query and understand the result. Please pay special attention to the first_name when I scroll over here. Very quickly, you will see the pattern that there is not a single name, which is starting with any letter which comes after N in alphabet. Now let's understand ‘greater than' operator and we will understand the same example a little bit more in depth. In our SELECT statement, in the WHERE condition, we have ‘actor_id > 100'. Let's execute this and see the resultset. The query has returned 100 rows. When we see the resultset, we can see actor_id starts at 100 and it goes all the way to 200. Any record with actor_id less than 100 is no more included in this resultset. In case of the second query, where we have first_name > ‘Nick", select the statement and click on Execute. Now let's go to the resultset. In this resultset, you can notice that every single name in the column first_name will be after NICK if they're ordered alphabetically. However, in both the cases of ‘greater than' and ‘less than', we have noticed that the actor_id 100 and first_name NICK was never included in the resultset. There can be a scenario where we need actor_id 100, as well as first_name NICK also included as a part of the resultset. We can do that if we use ‘less than or equal to' operator. Let's see that in this case. In the result pane, let's scroll down all the way and you can notice the very last_name is actor_id goes to 100. What it means is that this query has included 100 and every value which is less than 100 for actor_id. Similar logic also applies to first_name <= ‘Nick'. Let's select the statement and click on Execute. Now you can see that actor_id is equal to NICK is also included in the resultset right away. Same logic also applies if you are going to use ‘greater than or equal to' operator. Now, let's execute this query. You can see that we have now actor_id 100, as well as every actor_id over 100. When I execute this query, any name alphabetically after NICK, as well as it includes first_name NICK. Well, now you know how most of the comparison operators works. However, there is one more comparison operator, which is very important to learn -- not equal to. Not equal to negates the condition, which we have provided into WHERE clause. Let's understand that with an example. In this case, we have a condition where actor_id does not equal to 100. What it means is that we'll get every single result ‘WHERE actor_id <> 100'. Let's execute this query and we can see that now we have 199 rows in the resultset. If you scroll down and try to see between 99 and 101, there is now row 100 because ‘actor_id = 100' should not be included in the resultset. Similar case with ‘first_name != ‘Nick' as well. Let's execute this query and you can see NICK was actor_id 2. It's not included in this query. If you scroll down all the way, you will not find names equal to NICK. You will find resultset containing every other name besides NICK. Well, with this we complete our understanding of comparison operators. Let's go to our next concept of logical operators.

Select statement and Logical Operators

So far we have seen in the WHERE condition that we are using simple such condition. What it means is that we take one column name and try to compare it with string or integer literal. However, the real world scenario is much more complex than this. We sometimes have more than one condition to compare and validate. At that time, we need logical operators. Logical operators help WHERE condition to become a compound condition. We can use multiple logical operators and can build a complex WHERE condition. For example, here is the list of popular logical operators -- AND, OR, and NOT. AND operator is true if all the conditions in WHERE clause are True. OR operator is True if any one of the conditions in WHERE clause is True, whereas NOT is Negate Logic. What it means is that it will give us the logic, which we have used previously. Sometimes NOT operators tend to confuse developers because of the issue. I suggest you write your logic in such a way that you don't have to use NOT condition. Well, to understand this, we have to see a demo. Let's open MySQL Workbench and see them into action.

Demo: Logical Operators

Here, we are in MySQL Workbench in SQL Editor. Let's first see how AND operator works. Here is a simple example. From sakila.actor table, we are going to retrieve all the records ‘WHERE first_name = ‘KENNETH'. Select the statement, click on Execute, and you can see there are four rows retrieved over here. Let's make it a little bit more complicated. In WHERE clause, we add one more condition and the condition is that actor_id should be less than 100. Now if you carefully observe our resultset, you can see there are three records, which are ‘actor_id < 100', and one record, which has ‘actor_id > 100'. Now, because of this new addition in the WHERE clause, our resultset will not have four rows, but it should have three rows. Let's execute this and check the resultset. Now it's very clear that in our resultset we don't have actor_id, which is greater than 100, even though the first_name is KENNETH. Besides having ‘first_name = ‘KENNETH' AND ‘actor_id < 100', we have added one more condition where ‘last_name = ‘TORN'. Let's execute this and check the resultset. In our entire table, this is the only row which satisfies all three conditions, which is specified in WHERE clause. Now we will see how OR logic works. First, we will see a simple example and we will retrieve all the records ‘first_name = ‘KENNETH'. Now you can see we have retrieved four rows. Let's make it a little bit more complicated and we add one more OR into our WHERE clause. Right now, OR suggests ‘actor_id < 100'. What it means is that now our query should return everybody who has a ‘first_name = ‘KENNETH', as well any ‘actor_id < 100'. For example, looking at this condition, we know that following four rows will be part of the resultset. When we look at this condition independently, we also understand that there will be additionally 99 rows also part of our resultset and there is always a chance of overlay. What it means is that we'll definitely get all the record where ‘actor_id < 100', as well as one additional row where ‘actor_id > 100' and is 169 because it qualifies for condition ‘WHERE first_name = ‘KENNETH'. Let's validate our assumption by executing this query and let's scroll down. At the bottom of our resultset, we can see that we have retrieved every row, which has ‘actor_id < 99', as well retrieved row 169 because it has ‘first_name = ‘KENNETH' and that is also one of OR condition. Now you can see in the WHERE clause we have added ‘last_name = ‘TEMPLE'. What it means is that any row which has first_name as KENNETH or last_name as TEMPLE or ‘actor_id < 100' will be qualified for our resultset. Let's execute that and scroll all the way to the bottom. Now you can see that we have additional rows where ‘last_name = ‘TEMPLE' and all of these rows have ‘actor_id > 100'. Well, now let's move to our next logical operator, which is NOT. Well, NOT conditions are very simple conditions. They just negate the logic, which we have used in the WHERE clause. Let's see this example. Here, we will specify ‘actor_id = 50'. If we do not have a NOT, what it means is that this query will return as result ‘WHERE actor_id = 5'; however, because we have used NOT just right before our condition, what it means is that this query will return us every single result where we don't have ‘actor_id = 5'. Let's exhibit this query and relate it to our assumption. Well, in resultset, pay attention to actor_id column. There is no row between actor_id 4 and actor_id 6. What it means is that this query does not return us any result where ‘actor_id = 5'. Remember what I mentioned earlier? NOT sometimes confuses the user or developer if there is very complicated logic. You can relate this query without using NOT as well. Look at this example. Here, instead of using NOT, I have just changed the condition from ‘equal to' to ‘not equal to' and this query will also return as absolutely same result. Now we have understood all three of our logical operators. Now let's put all of them together and understand with much more complex examples. Here is our first example. We will use AND and OR together. Let's execute this query and we have retrieved seven rows. You can see this query has returned us everybody with the first_name as KENNETH and ‘actor_id < 100'. Additionally, it has also retrieved all the record where ‘last_name = ‘TEMPLE'. Remember, one more thing, which we just discussed a few minutes ago, which is logical operator precedence. Logical operator precedence is NOT, AND, and OR. What it means is that AND is evaluated first and OR is evaluated right after it. In this case, two conditions were evaluated first and later, they were ordered with this condition. Let's change this order of condition and we will see that we will get absolutely different result than what we have just got over here. Now here is the second query. What we have done here is that we just took this OR and moved it a little bit before AND and ‘AND actor_id' is now right after OR CONDITION. As for the precedence of operator, AND will be evaluated first. What it means is that these two conditions will be evaluated first. These two conditions will be evaluated first and later they will be ordered with ‘first_name = ‘KENNETH'. Even though both the queries have almost similar conditions, they have very different meaning. I selected the query and click on Execute. Now this query has returned as every record where ‘last_name = name' and ‘actor_id < 100'. What it means is that anybody who has a last name equal to TEMPLE, but actor_id is greater than 100, is not part of this resultset. KENNETH is an OR condition so anybody who has a first name equal to KENNETH will be always part of this resultset and, hence, we are able to see actor_id, which is 169, with first_name as KENNETH also part of this resultset. The concept, which we have just discussed, is a very, very important concept and I strongly encourage all of you to execute this query on a sakila Sample Database. Now let's make it a little bit more complicated and take this example to the next level. We'll start using parentheses to our logic, which we have just seen. Here are two examples. Let's execute this first query first and you can notice this query is very similar to the OR initial query. If you do not use parentheses in this logic, it will still give us same result. However, it's not true in this case. You can notice over here we have parentheses around ‘(actor_id < 100' OR ‘last_name = ‘TEMPLE')'. When you select everything together and execute, you can see that we'll now only get the result ‘WHERE first_name = ‘KENNETH'. Funny enough, you want to build the condition ‘WHERE last_name = ‘TEMPLE', none of the rows qualify because now we have additional conditions to our original resultset, which states ‘first_name = ‘KENNETH'. There is not a single actor who has last_name TEMPLE and first_name KENNETH. Now you can see the power of parentheses and order of precedence, how they play together, and keep on changing our result. Well, with this we end our logical operator section and let's move to the various other operators related to WHERE condition.

Select statement and WHERE clause

WHERE clause is one of the most powerful clauses in entire SELECT statement. There are lots of interesting elements, which we can use in the WHERE clause to make it interesting to learn. For example, IN phrase. We can use IN phrase to test whether expression is equal to the value in the least. The order of element in the least does not influence the final resultset. Additionally, we can use subquery in the IN clause as well. During demonstration, we will quickly see an example of the same. In the advanced course, we will cover this concept in detail. We can use NOT operator to negate the logic of IN phrase. BETWEEN phrase qualifies the row of a resultset when an expression falls within the range. The lower and the upper limit range expressions are also part of the range. Just like any other operator or phrase, we can use NOT to negate the resultset. We can use LIKE operator to retrieve rows that matches a string pattern. A string pattern is called a mask. We will also understand how Wildcard - % (percentage) and _ (underscore) helps to build this string pattern using demonstration. Additionally, we can use NOT keyword before LIKE and negate the entire logic. NULL is one of the most interesting concepts within Database. I have seen developers often getting confused with NULL. Incorrect implementation of NULL brings unexpected results. NULL value stands for value that is unknown or unavailable. It is not a 0 or not an infinite. In SQL, we can't compare NULL by using ‘equal to' operator. We are to use special clause of IS NULL and IS NOT NULL. When we use this clause, our resultset contains value based on this logic. Let's quickly jump to a demonstration and understand these concepts.

Demo: Using Between in WHERE clause

Let's open MySQL Workbench, SQL Editor, and let's start with our very first example. First, we will understand how IN works. Once again, we will be using sakila.actor table. ‘SELECT * FROM sakila.actor WHERE first_name IN (‘NICK', ‘JOHNNY', ‘JOE', ‘VIVIEN')'. What it means is that this query will return result where first_name is any of these names. Let's verify that. Select the statement and click on Execute. The data type of our literals was string, that's why we have a single code around them and they're all separated by comma. If the data type of our literal is integer, there is no need of single code around that. Let's see an example of that as well. Here it is. In this case, we have literals as integers. We do not need a single code around that. Our WHERE condition is ‘WHERE actor_id IN (1,2,3,4,5,6,7)'. Let's select the statement and click on Execute. You can see in the resultset, we have all the result ‘WHERE actor_id' is (1,2,3,4,5,6,7). Well the implementation of IN is very simple as you can see that. Now we will quickly see the example of the subquery. On a very first glance, we can see there are two different queries over here. First query is that where we are ‘SELECTING * FROM sakila.actor WHERE first_name IN (‘NICK', ‘JOHNNY', ‘JOE', ‘VIVIEN')' and there is an OR condition over here, which is looking for actor_id IN and then the result of second query. Let's write now second query, which is ‘(SELECT actor_id FROM sakila.actor WHERE last_name = ‘DEGENERES')'. Let's execute this query and see what is the resultset. When we run this resultset, we can see it returns us three distinct values, which is 41, 107, and 166. What it means is that there are three actors whose last_name is DEGENERES and their actor_id is 41, 107, and 166. That simplifies this query a lot. What it means is that ‘SELECT * FROM sakila.actor WHERE first_name IN (‘NICK', ‘JOHNNY', ‘JOE', ‘VIVIEN') OR actor_id IN (41, 107, 166). What it means is that we will get every record where first_name is either NICK, JOHNNY, JOE or VIVIEN. Additionally, there will be rows where actor_id will be 41, 107, and 166. To evaluate our assumption, let's select entire query and click on Execute. Carefully observe the first_name column of the resultset. You can see the name belongs to NICK, JOHNNY, JOE or VIVIEN. Additionally, there should be three record where actor_id's go to 41, 107, and 166. In case of the actor_id 41, we can clearly see it's over here, actor_id 2, 5, 9, 14, and 40, the logic was first_name belonged to our four names. In case of the actor_id 41, the last_name was DEGENERES and that's the reason it qualified for this resultset. Same logic is for 107 as well. This record qualifies for both of the conditions. What it means is that, if we had a condition instead of OR and here, actor_id 166 will be still a valid resultset. Instead of OR right here, AND. Now, we will execute this and you can see only one record is now in our resultset. This record is here because the first_name is NICK and the last_name is DEGENERES. Now let's understand how BETWEEN clause works, but before that let's execute a simple query. ‘SELECT * FROM sakila.actor WHERE actor_id > 10 AND actor_id < 20'. What it means is that it will get us every single actor_id, which is over 10 and less than 20. Let's select this and execute it. In the resultset, we have nine rows where actor_id is from 11 to 19. Here is an example: ‘SELECT * FROM sakila.actor WHERE actor_id BETWEEN 10 AND 20'. Now let's select this one and execute. When we execute this record, we can see that there are no more nine rows. The total number of the rows are 11. The difference between this query and the query, which we ran before, are row with actor_id 10 and row with actor_id 20. The reason is that the way the BETWEEN works is that it also includes both the ranges. What it means is that the 10 is also part of the range and 20 is also part of the range. The way the range logic works, in case of the BETWEEN is, lower range, upper range, and anything between them. If you want to simulate this query with using BETWEEN, you will have to change here something. Instead of 10, you are to replace that by 11 and instead of 20, you are to replace that by 19. Now, this query will be exactly similar to the query, which we have executed in the beginning just like this. Let's go further down. You can just put NOT before BETWEEN and it will just negate the complete logic over here. With the use of NOT keyword here, you will get every single row where actor_id is lower than 11 and actor_id is greater than 19. Let's evaluate that. Select the statement and click on Execute. Now let's go further down and you can see after 10, right after there is a value of 20. There is no other value in-between. It means rows with actor_id 11 and more and rows with actor_id 19 and less are all omitted. You can see the BETWEEN can be very powerful when we have to deal with range.

Demo: Using Like in WHERE clause

Now we will see how LIKE operator works. LIKE is very powerful and interesting because it works with patterns. Using pattern logic and Wildcard, you can pretty much build infinite combinations of the logic to use in a WHERE condition and let's start a few of them over here. Here are some of the examples. The first one is ‘SELECT * FROM sakila.actor WHERE first_name LIKE ‘A%'. This one pretty much will list every single actor whose first_name starts with A. Percentage means there's just one or more characters. Let's execute this one and you can see in our resultset, we have every single actor whose first_name starts with A. However, if you want to make it a little bit more interesting, we can select only actor whose first_name starts with A and L, which means we should get ALEC, ALBERT. ALBERT is here two times, which means actor_id 125 and actor_id 146 should be also part of our result. Let's execute this one and we will see. Here, we have WHERE condition ‘WHERE first_name LIKE ‘AL%'. In resultset, we have all the actors whose first_name now starts with AL. Well, we can make it more clarity as well. Here is an example. Here, we have used two underscores. Underscore stands for a single character. The pattern, which we have returned here, is the first character is A, second and third can be any other character; however, the fourth character has to be E. Let's exhibit this one and see how many records qualify for this pattern. When we execute this, we can only find one actor who qualifies for this kind of pattern, that is ANNE, because the first character is A, we do not get about second and third character, however, the fourth character has to be E. Additionally, when we write this kind of pattern, it means we are looking for a four-character string only. However, if we just put percentage right after it, now what it means is that we can have first character A, second and third we don't get; however, the fourth character must be E. When we put percentage right after E, it means now we don't care how long this particular string is. Well, let's execute this one and see if we find any actor with such a name. You can find there are many, ANGELA, ANGELINA, ALBERT, ANGELA, and ALBERT again, along with our original record of ANNE. You can see in all of these there is a single pattern. First character is A, fourth character is E; however, we do not get the length of them, as well as we do not get what is the second and third character is. Let's further continue to modify the same pattern. Here, instead of putting two underscores, now we have replaced two underscores with single percentage. Now what it means is that the first character is A and there is a percentage between A and E. What it means is that E doesn't have to be anymore the fourth character, E can be any character after A, and there can be any number of the characters between A and E and we do not care about them. Additionally, E does not have to be the fourth and last character, there can be more characters right after percentage as well. What it means is that, find the name, but start with A and has E anywhere in the name except for splits. Let's execute this one and you can find many of the records. Now we can see the position of E is not fixed, in this case it's third and in this case it's second to last. Again, in the case of ANNE, it's the fourth and in the case of ANGELA, it is also fourth. Well, now there is no real logic where the E is going to be; however, you can notice that A is always the first character. Now let's go to our next concept, which about NULL. As we said, NULL is very interesting and it's very important to understand how NULL's behave. We cannot use any arithmetic or logical operators over NULL. To compare NULL, you just have to use special keyword, which is IS NULL or IS NOT NULL. Let's go to our address table and select every single record from it. You can see in column address2, there are four records which are NULL and other records have empty string. Let's go to our second query and run it. Please pay special attention here, the WHERE condition is address2 IS NULL. What it means is that every record where address 2 IS NULL, should be part of the resultset. Select the query and execute it and you can see that our four records over here where address2 IS NULL. If you want to make it this condition, select the query and execute and now you will get every single row where address2 IS NOT NULL. Well, logical to NULL is very interesting and now starts playing a very crucial role when we start using outer joins. With this, we finish our demonstration regarding WHERE clause. Now we will go to our next concept of ORDER BY clause.

Select statement and ORDER BY clause

The ORDER BY clause specifies sort order of the resultset. The sort order can be ascending or descending. Additionally, we can sort the resultset by one column or multiple columns. We can also use various expressions in ORDER BY clause as well. ORDER BY clause is the only clause where we can use alias to sort columns as well. Additionally, we can use column number to specify sort order as well. ORDER BY clause has a very special behavior with NULL values. NULL values always appear first in the sort sequence. It does not matter if you specify sort sequence, ascending or descending. Additionally, remember that you can sort any column in the base table regardless if you have used that one in the SELECT statement or not. Let's see some of the interesting examples of how ORDER BY clause works in the next demonstration.

Demo: Select statement and

Now you open MySQL Workbench and SQL Editor. We will be seeing examples of how ORDER BY works. Let's start with a very simple example, here it is, ‘SELECT * FROM sakila.address ORDER BY district'. Select the statement and click on Execute. In the resultset, pay attention to the distinct column. You can notice that the distinct column is now ordered alphabetically in ascending order. Abu Chabi is on the top and Zulia at the end. Now, if you want to reverse the order of this column, what it means is that you want Zulia on the top and Abu Chabi on the bottom. You can easily do it if you just specify descending keyword in an ORDER BY clause. Here is the example. Let's select the statement and click on Execute. You can see that now Zulia is on the top and if you scroll all the way to bottom, Abu Chabi is at the end. Now let's see another example where we have more than one column in ORDER BY clause. Let's select this one and Execute. Let's take the example of Abu Chabi itself. You can see that Abu Chabi is on the top. It is ordered in ascending sequence by column distinct. If you pay attention to the postal_code, you can see that the higher number is on the top and lower number is on the bottom. What it means is that in this window of Abu Chabi, MySQL has once again sorted postal_codes. However, the order of the postal_code is descending, hence, you can see the value, which is higher on the top and the value, which is lower on the bottom. Similar example is also here in Adna. You can see that higher number is on the top, where lower number in the postal_code column is on the bottom. Now, let's see a different example. Here it is, where we have our expression in a SELECT statement. You can see that here we have actor_id from sakila.actor table and we are concatenating first_name and last_name and we are aliasing first_name and last_name as FullName. We can order this complete table by expression using the SELECT statement. For example, we can use this concat in our ORDER BY clause as well. Let's select this complete statement and Execute. You can see that now complete table is now ORDER BY expression, which you have specified in ORDER BY clause. To make things simple, we can also use alias in ORDER BY clause as well. You can see here that instead of using expression, we are using the alias, which we have given in SELECT statement in ORDER BY clause. Let's select this one and click on Execute. The resultset is very similar to the one we called; however, it's very easy to read and easy to write as, instead of writing complete expression, we can just replace it with alias. Well, there is one more trick I want to show you. Here, in ORDER BY, we have used digit 2. Digit 2 stands for column #2, which is in a SELECT statement. What it means is that actor_id is column 1 and concat expression is column 2. Let's exhibit this one. You can see that our resultset is ORDER BY second column, which is concatenating of first_name and last_name. If we remove these two and put over here 1, it will be ORDER BY actor_id. Let's see that. Select the statement, click on Execute, and you can see that now complete resultset is ORDER BY actor_id column. Well, personally I do not like this method because this method can create ambiguity when we are using the * or when we have a schema change or some developer adds column in a SELECT clause. I personally prefer to use complete expression or alias of the column in ORDER BY clause. Well with this, we finish our understanding of ORDER BY clause.

Retrieving limited rows

Now we have reached to very last concept, which we want to learn in this module, which is LIMIT clause. We can use LIMIT clause to limit the number of the rows that are returned by SELECT statement. This clause usually has one or two arguments. Each of them has different meaning and we will understand them while we do demonstration. It's always recommended that we use ORDER BY along with LIMIT because there is no guarantee when we use LIMIT that we are going to get the data in the same order in every subsequent execution of the same SELECT statement. The frequent use of this LIMIT clause is when we are doing paging. Think about it this way. If there are 1000 rows in one table and now you want to retrieve only row, which is between 500 and 510, how would you go about retrieving them? Well, this is the time that you use the LIMIT clause because LIMIT clause has a two-argument, one is number of the rows and second one is offset. Let's quickly understand both of them in demonstration.

Demo: Retrieving limited rows

Here we are in MySQL Workbench in SQL Editor and we are going to see how LIMIT keyword works. As mentioned earlier, LIMIT keyword is a pretty straightforward keyword. Let's first retrieve data from sakila.actor, where we have ORDER BY clause on actor_id. Let's go and apply LIMIT 10. What it does is that when we execute this statement, it will only retrieve 10 rows; however, what happens if you want to retrieve data, which is somewhere in-between the table? What it means is that you want to retrieve row #30 to 35 or row #50 to 65. At that time, you can additionally specify offset to the LIMIT clause. This is how it works. Look at this example where we have LIMIT 15 and 10. Well, these have two parameters. Let's execute them and understand what each of these parameters do. When you execute this query, you can see that the first record is no more actor_id 1, it is now actor_id 16. The first parameter, which we provided to LIMIT keyword, is offset. What it means is that if you specify you had 15, MySQL would skip first 15 lines and would start reading the lines after that. Here, if I specify 10, what it means is that is only going to retrieve 10 rows. Let's change this number and see one more example. For that, I'm going to put here 25 and number of the rows I'm going to put 5. What it will do is that it will start retrieving rows from row #26 and will retrieve till row #30 because we are going to retrieve only five rows. Now, let's select this one and click on Execute. As we expected, it is retrieving us five rows from the actor_id 26 and onwards. As LIMIT clause limits the number of the rows it retrieves from the offset, it also helps with performance of overall server health. Well, with this we end our understanding of data retrieval and it's various clauses, phrase, and operators. In the next module, we will see data modification techniques and now we end this module with summary in sixty seconds.

Summary in Sixty Seconds

Summary in Sixty Seconds SELECT clause describes the column lists in the resultset. FROM clause describes the table names from which the query retrieves the data. WHERE clause describes the condition to match for rows to qualify for resultset. ORDER BY clause describes the sort order and sequence for resultset. LIMIT clause describes the number of the rows resultset returns and offset of it. Use column names in SELECT statement instead of * to reduce ambiguity and impact performance. Using aliases improves readability. Use various comparisons and logical operators in WHERE clause to retrieve rows relevant to application. Always use ORDER BY clause if you want your resultset ordered.

Data Modification Techniques

Introduction

Hi, this is Pinal Dave for Pluralsight and in this module, we will discuss about Data Modification Techniques. Our major focus in this module will be on INSERT, UPDATE, and DELETE Statement. With UPDATE and DELETE, we will be also using WHERE clause. All the operators and phrases, which we have learned in an earlier module, will apply over here as it is. Each of the statements have two clear distinct areas. The first area is how to modify a single row and second area is how to modify multiple rows. Also, it's not a good idea to modify your live data. For the same reason, I'll be creating a sample table and will be doing all the operations on top of sample table. Let's start with INSERT Statement.

Insert Statement

We use INSERT Statement when we are to add one or more rows to a table. To insert a single row, we can specify INSERT command with table name and column list followed by the data, which we want to insert. Also, we can use SELECT statement to populate another table as well. When we want to insert multiple rows, at the same time, same logic applies. We can use one insert in multiple VALUE clause or SELECT statement, which returns us multiple rows. There are two important things to keep into focus while learning about INSERT Statement -- one is Default Values and second is NULL Values. We will understand all of these things in demonstration next.

Demo: Insert Statement

Let's open MySQL Workbench and SQL Editor and now we will see a few of the examples of how INSERT works. We'll start with creating a sample table and we'll be inserting all the data into this sample table. This is how we make sure that we do not upset live data. We'll be using Database sakila. We'll create a table, which is ActorSample. It has actor_id, first_name, last_name, and last_update. Actor_id is small integer and it's unsigned; however, it's NOT NULL and it's AUTO_INCREMENTING. As we are not specifying any other properties of AUTO_INCREMENT, it will start with 1 and will increment the value of the column by 1 as well. The first_name is varchar and it's NOT NULL, last_name is NULL, and last_update is timestamp data type and it's also NOT NULL; however, there is an important property defined here, which is DEFAULT. The default value of this column is CURRENT_TIMESTAMP. What it means is that if you do not specify any value to be inserted for last_update column, it will be automatically populated by CURRENT_TIMESTAMP. Let's start with our very first example of INSERT. Let's execute this one and you can see in Output, it has already created a table for us. Now we'll start with a very simple example where we will insert a single row into the table. The script is ‘INSERT INTO table name sakila.actorsample'. Here, specified here three of our column -- those are first_name, last_name, and last_update. Please note that we are not specifying here column actor_id. The reason of that is very simple. It's going to be AUTO_INCREMENT. What it means is that we do not have to explicitly enter data into this column. As and when we insert data, this will be auto-populated by AUTO_INCREMENT property of a column. Let's see example of that as well. We are going to use VALUE clause right after the INSERT Statement. In the VALUE clause, we are going to specify the property, first_name I'm specifying Pinal, last_name as Dave, and last_update as any date. Let's select this one and click on Execute. You can see in OUTPUT clause, the message is ‘1 row affected'. Now let's check the data into this table. Select ‘SELECT * FROM' table and click on Execute. You can see that has inserted one row, which is actor_id 1 because it's the first value, first_name Pinal, last_name Dave, and last_update date, which we have just specified. As in our INSERT, we did not specify any of the time component, it has by default assumed time component of 00-00. Now let's go to second script. Here is the second script. Let's compare this one with the first one. You can see there are two major differences. First is there are no column lists in the second script and the second is default specified over here. Let's first execute this one and we'll talk about that afterwards. Click on Execute and now check the data. We have successfully inserted the second row and it states Nupur Dave in the date. If you notice, it's the same data which we have just inserted; however, in earlier one, we did not specify actor_id because actor_id was auto-populated. However, when we are inserting data into table and not specifying the list of the column, at that time we will have to specify every single column's value in the value list, as well as it has to be in the same order as the original table. What it means is that this default stands for actor_id, Nupur for first_name and Dave for last_name, as well as the date, which we have specified is for the fourth column. Column order has to match to the original order. If I change the order of Dave in the date, it's not going to insert the data properly and it may give us Error. If we do not specify default, MySQL will also give an Error. When we specify the default, it will go and take the default value for this column. In this case, the default value will be AUTO_INCREMENTED and AUTO-INCREMENT will be adding 1 to the original value as we have not specified any other AUTO_INCREMENT data. That means we will have value 2 over here. Well, let's continue with our next example. In this example, you can see that now we have only two columns where we are inserting data -- one is first_name and second one is last_name -- and the data, which we are inserting, is Pinal Dave. Let's think for a moment what would happen in this case. In case of the first_name, the value Pinal will go; in case of the last_name, the value Dave will go. What will be the value of last_update? Let's go and check the value in our table definition. In table definition, we have specified the last value is of data type timestamp and will have a default value of CURRENT_TIMESTAMP. What it means is that if you do not specify the last_update, it will automatically take the current date/time of the Server where MySQL is installed. Let's exhibit this and relate it to our assumption. Select the statement, click on Execute, and now select the data from table. You can see over here that third record is inserted with first_name Pinal, last_name Dave, and the date is current date/time from my system. Now, let's go to next script and understand that. In our next script, we have only one column specified in our INSERT Statement and the value is Pinal. There is no value for last_name, as well as last_update and actor_id. Let's try to guess what will be the value in each of these columns? Well, in case of the actor_id, once again we will have AUTO_INCREMENT value and we will see 4. In case of the last_update, as we have noticed, we will have the current date/time of Server, but what will be the value of the last_name. Let's go to our column definition one more time and see what it will be. You can see last_name column is defined as NULL. What it means is that if you pass any value to this column, it will take that value, but if you do not pass any value to this column, it will just take that as a NULL. Well, let's execute this and validate that. Select the statement and click on Execute. As we have expected, actor_id is 4, first_name is Pinal, last_update is current date/time of the Server, but the value of the last_name column is NULL. Isn't this interesting? That sometimes we feel that we are to specify every single column, but as we start narrowing down, we learn that there are so many things, which are dependent on the definition of table, which we have defined earlier. That is why Data Modeling is considered as one of the most challenging tasks. Now, let's try to do the same thing with last_name Dave. Here, we have not specified the first_name, but we are only specifying the last_name. What do you think will happen? Let's go all the way up and see here the first_name only states it's NOT NULL. There is no default value specified. What is means is that this column has to have a value. If we do not specify what to be inserted into this column, MySQL will not let the entire row to be inserted into this table. Let's see that into action. Now we select the statement and click on Execute and on the bottom over here, you can see that there is an Error. Error states first row does not have a default value. What it means is that if you do not have a default value, you will have to insert some data in it. You cannot just walk away without specifying any value for the column, which is marked as NOT NULL and does not have a default. Well, let's see one more example. Insert into table name, column's first_name, last_name, and last_update. The value Pinal will go into first_name and NULL will go into last_name and default value will go into last_update. What will happen over here is that we will see in the first_name column value Pinal, in last_name NULL, and last_update current date/time of the system. Let's select the statement and execute it. Now, we'll go and check the data into the table. You can see actor_id 5 is over here and first_name is Pinal, last_name is NULL, our Server's default date/time is in last_update column. Now, let's go a little bit more advanced and see how we can insert multiple rows. So, here is the example where we will see how we can set multiple values into table. The first method is very simple and very easy to increment. We have INSERT INTO table name and column name listed over here. In VALUE clause, we have first column and comma and second column and a comma and we have third column. We can have more than three columns over here as well. With this kind of syntax, we do not have to specify INSERT Statement again and again. Let's execute this one and now select the data. Scroll down and you can see now we have three records inserted, which is Pinal Dave with date 17, Nupur Dave with date 18, Shaivi Dave with date 19. There is one more method where we can use SELECT statement to insert data. For example, if you want to insert all the data where the actor's first_name is Nick into this table, we can use this kind of syntax. Let's see the SELECT statement first. There you can see we have three names with actor's first_name is Nick. Now, we will just write INSERT statement just on the top of this SELECT statement. In INSERT, we have three columns -- first_name, last_name, and last_updated. In case of the SELECT statement, let's select everything and click on Execute. When we execute, we can see there are three rows, which are returned. Let's go and check the data. SELECT * FROM ActorSample and click on Select. Let's scroll down all the way to the bottom and you can see that there are three new records, which are inserted, which is NICK WAHLBERG, NICK STALLONE, and NICK DEGENERES. Well, you can see how easy it is to insert data into table by using SELECT statement. Let's clean up and drop this table. Now, in the next clip we will learn about UPDATE statement.

Update Statement

We can use UPDATE statement to update one or more rows in a table. The SET clause in UPDATE statement will contain name of the column and its new value, whereas WHERE clause will have a condition, which qualifies rows to be updated to a new value. Just like INSERT, we have a concept of default and NULL here as well and they work almost exactly the same. Let's see UPDATE in action. UPDATE has many variations. For example, update single row and single column, update single row and multiple columns, we can also update multiple rows in single column or update multiple rows in multiple columns. We can use SELECT subquery in UPDATE statement as well. Let's see all of this into action now.

Demo: Update Statement

Now, let's see UPDATE statement into action. We'll be using sakila database and we'll be creating our custom table. We want to make sure the table, which we use, does not modify any of the live or production system. The table, which we are going to create, is almost the same table which we have created in our INSERT script. Click on Create Table script and click on Execute. This script is very similar to the script, which we have used in our INSERT statement demonstrations. Click on Execute and now, new table, which is sakila.actorsample, is populated with the same data of sakila.actor. First, we will learn about Update Single Row Using Single Column. Here is the UPDATE statement where we are updating sakila.actorsample. SET keyword has first_name. Every single row in the first column will be now populated with Pinal. What we want to do is that we only want to update the value of the first record where ‘actor_id = 1'. Now we are limiting our update to only one column and one row and now, before we check our data, we'll do the same operation with the last_name as well. What it means is that we'll now update the last_name column to value Dave where actor_id is also 1. Let's select this one and click on Execute. Now let's go back and check our data. The value of the first_name is Pinal and the value of the last_name is Dave. Now, let's move further. In an earlier example, we have updated first_name and last_name separately. We do not have to do that. We can update first_name and last_name of single row or together. For example, over here, I'm going to update the row where ‘actor_id = 2' with first_name Pinal and last_name Dave. Please note, the current value are NICK and WAHLBERG. Now, let's execute this script and do select on the table. You can see the OR value is now replaced with Pinal and Dave. This time, we did not have to write two separate UPDATE statements to update a single row. We can update a single row with multiple columns by specifying all the columns into SET clause. Let's take this one into next level. Carefully observe the WHERE clause. WHERE clause has actor_id and list of the actor_id. What it means is that every actor_id with value 3, 4 or 5 will be now updated with the value Pinal. Let's execute this and check our data. Upon checking our data, we can see this change also happened over here. Well, what we did is that we specified a list and multiple rows were updated for a single column. We can take it to the further next level where we update multiple columns and multiple rows. Here is the example. Here, we have WHERE condition where actor_id in 6, 7 or 8, which means these are the three rows which we are discussing over here. We are updating first_name with Pinal, last_name with Dave, and last_update with DEFAULT value. DEFAULT value will populate current date/time of the Server in the column. Let's select this one and click on Execute and now, check the data. In resultset, we can clearly see that 6, 7, and 8 row has now Pinal Dave value everywhere and last_update date is updated to current date/time. Let's see one more concept. Here is the concept of using subqueries. We have UPDATE statement where we are updating sakila.actorsample and setting value first_name to Nupur and WHERE condition has actor_id. However, let's pay additional attention to the WHERE clause. Here, we have subquery in our WHERE clause. Let's execute the subquery independently and you can see the subquery is returning its value of 1, 10, 20, 40, 50, and so onwards. These are the lists of actor_id who all work in the ‘film_id = 1'. What it means is that all these actors work in a single film, which has ‘film_id = 1'. Now we will change the first_name of every single actor who has acted in the film 1 to Nupur. Let's execute this one. Well, Execute did not happen successfully and we can see that in Error. Error Code 1175: You are using safe update mode and you tried to update a table without WHERE clause. Now, we are definitely using a WHERE clause; however, by default, MySQL Workbench works into safe mode. Let's change that. Let's go to Edit and go to Preference, go to SQL Queries, and here uncheck Safe Update. Additionally, it also requires us to do reconnection. I unchecked this option and click on OK. Now click on this icon, which suggests reconnect to DBMS. Now, once again, try to run this query. This time, query is ran successfully and it has updated 10 rows. Let's go to our table and check the data in it. We can see the very first row is now updated to Nupur because ‘actor_id = 1' was also actor in a ‘film_id = 1'. Scrolling down, we can see another value where actor_id is 10. Now you can see how easy it is to update single and multiple rows in MySQL. We can use complex logic in the WHERE clause, as well as subquery to update our data. Let's do cleanup and drop our table. Next, we'll see another important concept of Delete.

Delete Statement

DELETE statement is one of the most powerful statements. It can delete every single row in your table pretty much with one line of syntax. However, we should make sure that we are using a WHERE clause with DELETE statement so we delete one or more rows from table instead of deleting every single row. We can also use subquery and SELECT statement to qualify row to delete in DELETE statement. If we forget the WHERE clause, we'll pretty much delete every single row from the table. Let's see all of this concept into action next.

Demo: Delete Statement

Here, we are in MySQL Workbench in the SQL Editor and we'll see an example of DELETE statement. We'll be using sakila database and now we'll create very similar table, which we have created in earlier examples. Table is ActorSample and has four columns -- actor_id, first_name, last_name, and last_update. Click on Execute and table is successfully created. Now we will populate the table with sakila.actor table. We'll be using INSERT statement. Insert into sakila.actorsample column names and we'll be retrieving the same column from sakila.actor table. Let's execute this one and now we have our sample table ready, which we will use to exercise our DELETE statement. Let's see our very first example. Here, we are going to delete a single row. First, let's select our data. You will see in our data that our first row is actor_id 1 and first_name is Pinal and last_name is Dave. Let's execute this statement where we have ‘DELETE FROM table name WHERE actor_id = 1'. If you look at this statement, the structure from FROM is very similar to SELECT, as well as UPDATE. Click on Execute and now, once again, check your data. We can see that in data, the actor_id 1 row is now deleted. Well, let's go further down and this time, try to delete multiple rows together. We are going to use a list in WHERE clause ‘WHERE actor_id IN (3,4,5)'. Let's select this entire statement and click on Execute. Upon selecting the data, we can see that we no more have row 3, 4, and 5. This is how you can use WHERE clause in a SELECT statement to delete one or multiple rows. However, just like UPDATE statement, you can be creating with subquery in DELETE statement as well. Here, we have a subquery where we are selecting all the actor_id who work in the ‘film_id = 1'. Select the statement and click on Select. You can see various actor_id over here, actor_id 10, 20, and 30 - let's remember them for a moment and our DELETE statement states ‘DELETE FROM table name WHERE actor_id' into this all actor_id's. Let's select the entire statement and click on Execute. Upon checking the data in the table, we can see that now we do not have record id 10, 20 or 30 over here. They all got deleted because we executed this DELETE statement. You can observe the DELETE statement is extremely easy to do. Just missing a WHERE condition is capable to delete an entire table as well. Let's see that in our next example. Here, we do not have any WHERE clause. What it means is that, now, entire table sakila.actorsample will be deleted. Select the statement and click on Execute. If you are paying attention to our Output Window, you can see that it displays 187 rows affected. Actually, they're all deleted. Now, let's go to ‘SELECT * FROM ActorSample'. Click on Execute and we are getting no rows over here. The reason was that we did not use the WHERE clause and that's why every single record from this table has been deleted. Well, with this we complete our demonstration for Data Modification. Let's clean up by executing this statement. And now we will see Summary in Sixty Seconds.
